/* game.c generated by valac 0.32.0, the Vala compiler
 * generated from game.vala, do not modify */

/* modules: sdl2 engine gee-0.8 tiled*/
/* vapidirs: ../engine ../tmx*/

#include <glib.h>
#include <glib-object.h>
#include <SDL2/SDL_video.h>
#include <SDL2/SDL_render.h>
#include <SDL2/SDL_events.h>
#include <SDL2/SDL_scancode.h>
#include <SDL2/SDL.h>


#define TYPE_GAME (game_get_type ())
#define GAME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME, Game))
#define GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME, GameClass))
#define IS_GAME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME))
#define IS_GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME))
#define GAME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME, GameClass))

typedef struct _Game Game;
typedef struct _GameClass GameClass;
typedef struct _GamePrivate GamePrivate;

#define TYPE_TEXTURE_MANAGER (texture_manager_get_type ())
#define TEXTURE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TEXTURE_MANAGER, TextureManager))
#define TEXTURE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TEXTURE_MANAGER, TextureManagerClass))
#define IS_TEXTURE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TEXTURE_MANAGER))
#define IS_TEXTURE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TEXTURE_MANAGER))
#define TEXTURE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TEXTURE_MANAGER, TextureManagerClass))

typedef struct _TextureManager TextureManager;
typedef struct _TextureManagerClass TextureManagerClass;

#define TYPE_FONT_MANAGER (font_manager_get_type ())
#define FONT_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FONT_MANAGER, FontManager))
#define FONT_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FONT_MANAGER, FontManagerClass))
#define IS_FONT_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FONT_MANAGER))
#define IS_FONT_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FONT_MANAGER))
#define FONT_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FONT_MANAGER, FontManagerClass))

typedef struct _FontManager FontManager;
typedef struct _FontManagerClass FontManagerClass;

#define TYPE_GAME_STATE (game_state_get_type ())
#define GAME_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME_STATE, GameState))
#define GAME_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME_STATE, GameStateClass))
#define IS_GAME_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME_STATE))
#define IS_GAME_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME_STATE))
#define GAME_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME_STATE, GameStateClass))

typedef struct _GameState GameState;
typedef struct _GameStateClass GameStateClass;
#define _SDL_DestroyWindow0(var) ((var == NULL) ? NULL : (var = (SDL_DestroyWindow (var), NULL)))
#define _SDL_DestroyRenderer0(var) ((var == NULL) ? NULL : (var = (SDL_DestroyRenderer (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _game_state_unref0(var) ((var == NULL) ? NULL : (var = (game_state_unref (var), NULL)))

#define TYPE_TESTLEVEL (testlevel_get_type ())
#define TESTLEVEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TESTLEVEL, Testlevel))
#define TESTLEVEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TESTLEVEL, TestlevelClass))
#define IS_TESTLEVEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TESTLEVEL))
#define IS_TESTLEVEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TESTLEVEL))
#define TESTLEVEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TESTLEVEL, TestlevelClass))

typedef struct _Testlevel Testlevel;
typedef struct _TestlevelClass TestlevelClass;

struct _Game {
	GObject parent_instance;
	GamePrivate * priv;
};

struct _GameClass {
	GObjectClass parent_class;
};

struct _GamePrivate {
	gboolean running;
	SDL_Window* window;
	SDL_Renderer* renderer;
	TextureManager* textureManager;
	FontManager* fontManager;
	GameState* state;
};


static gpointer game_parent_class = NULL;

GType game_get_type (void) G_GNUC_CONST;
GType texture_manager_get_type (void) G_GNUC_CONST;
GType font_manager_get_type (void) G_GNUC_CONST;
gpointer game_state_ref (gpointer instance);
void game_state_unref (gpointer instance);
GParamSpec* param_spec_game_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_game_state (GValue* value, gpointer v_object);
void value_take_game_state (GValue* value, gpointer v_object);
gpointer value_get_game_state (const GValue* value);
GType game_state_get_type (void) G_GNUC_CONST;
#define GAME_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GAME, GamePrivate))
enum  {
	GAME_DUMMY_PROPERTY
};
Game* game_new (gint width, gint height);
Game* game_construct (GType object_type, gint width, gint height);
TextureManager* texture_manager_new (void);
TextureManager* texture_manager_construct (GType object_type);
FontManager* font_manager_new (void);
FontManager* font_manager_construct (GType object_type);
Testlevel* testlevel_new (TextureManager* textureManager, FontManager* fontManager, SDL_Renderer* renderer);
Testlevel* testlevel_construct (GType object_type, TextureManager* textureManager, FontManager* fontManager, SDL_Renderer* renderer);
GType testlevel_get_type (void) G_GNUC_CONST;
gboolean game_is_running (Game* self);
void game_handle_events (Game* self);
void game_state_togglePause (GameState* self);
void game_update (Game* self);
void game_state_update (GameState* self);
void game_quit (Game* self);
static void game_finalize (GObject* obj);


Game* game_construct (GType object_type, gint width, gint height) {
	Game * self = NULL;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	SDL_Window* _tmp2_ = NULL;
	SDL_Window* _tmp3_ = NULL;
	SDL_Renderer* _tmp4_ = NULL;
	TextureManager* _tmp5_ = NULL;
	FontManager* _tmp6_ = NULL;
	SDL_Window* _tmp7_ = NULL;
	TextureManager* _tmp8_ = NULL;
	FontManager* _tmp9_ = NULL;
	SDL_Renderer* _tmp10_ = NULL;
	Testlevel* _tmp11_ = NULL;
	self = (Game*) g_object_new (object_type, NULL);
	self->priv->running = TRUE;
	_tmp0_ = width;
	_tmp1_ = height;
	_tmp2_ = SDL_CreateWindow ("Yviland", (gint) SDL_WINDOWPOS_CENTERED_MASK, (gint) SDL_WINDOWPOS_CENTERED_MASK, _tmp0_, _tmp1_, (guint32) SDL_WINDOW_RESIZABLE);
	_SDL_DestroyWindow0 (self->priv->window);
	self->priv->window = _tmp2_;
	_tmp3_ = self->priv->window;
	_tmp4_ = SDL_CreateRenderer (_tmp3_, -1, (guint32) (SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC));
	_SDL_DestroyRenderer0 (self->priv->renderer);
	self->priv->renderer = _tmp4_;
	_tmp5_ = texture_manager_new ();
	_g_object_unref0 (self->priv->textureManager);
	self->priv->textureManager = _tmp5_;
	_tmp6_ = font_manager_new ();
	_g_object_unref0 (self->priv->fontManager);
	self->priv->fontManager = _tmp6_;
	_tmp7_ = self->priv->window;
	SDL_ShowWindow (_tmp7_);
	_tmp8_ = self->priv->textureManager;
	_tmp9_ = self->priv->fontManager;
	_tmp10_ = self->priv->renderer;
	_tmp11_ = testlevel_new (_tmp8_, _tmp9_, _tmp10_);
	_game_state_unref0 (self->priv->state);
	self->priv->state = (GameState*) _tmp11_;
	return self;
}


Game* game_new (gint width, gint height) {
	return game_construct (TYPE_GAME, width, height);
}


gboolean game_is_running (Game* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->running;
	result = _tmp0_;
	return result;
}


void game_handle_events (Game* self) {
	SDL_Event event = {0};
	g_return_if_fail (self != NULL);
	while (TRUE) {
		SDL_Event _tmp0_ = {0};
		gint _tmp1_ = 0;
		SDL_Event _tmp2_ = {0};
		SDL_EventType _tmp3_ = 0;
		_tmp1_ = SDL_PollEvent (&_tmp0_);
		 (event);
		event = _tmp0_;
		if (!(_tmp1_ == 1)) {
			break;
		}
		_tmp2_ = event;
		_tmp3_ = _tmp2_.type;
		switch (_tmp3_) {
			case SDL_QUIT:
			{
				self->priv->running = FALSE;
				break;
			}
			case SDL_KEYDOWN:
			{
				SDL_Event _tmp4_ = {0};
				SDL_KeyboardEvent _tmp5_ = {0};
				SDL_Keysym _tmp6_ = {0};
				SDL_Scancode _tmp7_ = 0;
				_tmp4_ = event;
				_tmp5_ = _tmp4_.key;
				_tmp6_ = _tmp5_.keysym;
				_tmp7_ = _tmp6_.scancode;
				if (_tmp7_ == SDL_SCANCODE_P) {
					GameState* _tmp8_ = NULL;
					_tmp8_ = self->priv->state;
					game_state_togglePause (_tmp8_);
				}
				break;
			}
			default:
			break;
		}
	}
	 (event);
}


void game_update (Game* self) {
	SDL_Renderer* _tmp0_ = NULL;
	SDL_Renderer* _tmp1_ = NULL;
	GameState* _tmp2_ = NULL;
	SDL_Renderer* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->renderer;
	SDL_SetRenderDrawColor (_tmp0_, (guint8) 60, (guint8) 128, (guint8) 200, (guint8) 255);
	_tmp1_ = self->priv->renderer;
	SDL_RenderClear (_tmp1_);
	_tmp2_ = self->priv->state;
	game_state_update (_tmp2_);
	_tmp3_ = self->priv->renderer;
	SDL_RenderPresent (_tmp3_);
}


void game_quit (Game* self) {
	g_return_if_fail (self != NULL);
	SDL_Quit ();
}


static void game_class_init (GameClass * klass) {
	game_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GamePrivate));
	G_OBJECT_CLASS (klass)->finalize = game_finalize;
}


static void game_instance_init (Game * self) {
	self->priv = GAME_GET_PRIVATE (self);
}


static void game_finalize (GObject* obj) {
	Game * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_GAME, Game);
	_SDL_DestroyWindow0 (self->priv->window);
	_SDL_DestroyRenderer0 (self->priv->renderer);
	_g_object_unref0 (self->priv->textureManager);
	_g_object_unref0 (self->priv->fontManager);
	_game_state_unref0 (self->priv->state);
	G_OBJECT_CLASS (game_parent_class)->finalize (obj);
}


GType game_get_type (void) {
	static volatile gsize game_type_id__volatile = 0;
	if (g_once_init_enter (&game_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GameClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) game_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Game), 0, (GInstanceInitFunc) game_instance_init, NULL };
		GType game_type_id;
		game_type_id = g_type_register_static (G_TYPE_OBJECT, "Game", &g_define_type_info, 0);
		g_once_init_leave (&game_type_id__volatile, game_type_id);
	}
	return game_type_id__volatile;
}



