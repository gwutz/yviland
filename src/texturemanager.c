/* texturemanager.c generated by valac 0.32.0, the Vala compiler
 * generated from texturemanager.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL2/SDL_render.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_rect.h>
#include <float.h>
#include <math.h>


#define TYPE_TEXTURE (texture_get_type ())
#define TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TEXTURE, Texture))
#define TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TEXTURE, TextureClass))
#define IS_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TEXTURE))
#define IS_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TEXTURE))
#define TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TEXTURE, TextureClass))

typedef struct _Texture Texture;
typedef struct _TextureClass TextureClass;
typedef struct _TexturePrivate TexturePrivate;
#define _SDL_DestroyTexture0(var) ((var == NULL) ? NULL : (var = (SDL_DestroyTexture (var), NULL)))

#define TYPE_TEXTURE_MANAGER (texture_manager_get_type ())
#define TEXTURE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TEXTURE_MANAGER, TextureManager))
#define TEXTURE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TEXTURE_MANAGER, TextureManagerClass))
#define IS_TEXTURE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TEXTURE_MANAGER))
#define IS_TEXTURE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TEXTURE_MANAGER))
#define TEXTURE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TEXTURE_MANAGER, TextureManagerClass))

typedef struct _TextureManager TextureManager;
typedef struct _TextureManagerClass TextureManagerClass;
typedef struct _TextureManagerPrivate TextureManagerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _Texture {
	GObject parent_instance;
	TexturePrivate * priv;
};

struct _TextureClass {
	GObjectClass parent_class;
};

struct _TexturePrivate {
	SDL_Texture* texture;
};

struct _TextureManager {
	GObject parent_instance;
	TextureManagerPrivate * priv;
};

struct _TextureManagerClass {
	GObjectClass parent_class;
};

struct _TextureManagerPrivate {
	GeeMap* map;
};


static gpointer texture_parent_class = NULL;
static gpointer texture_manager_parent_class = NULL;

GType texture_get_type (void) G_GNUC_CONST;
#define TEXTURE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_TEXTURE, TexturePrivate))
enum  {
	TEXTURE_DUMMY_PROPERTY
};
Texture* texture_new (SDL_Texture** texture);
Texture* texture_construct (GType object_type, SDL_Texture** texture);
SDL_Texture* texture_get_texture (Texture* self);
static void texture_finalize (GObject* obj);
GType texture_manager_get_type (void) G_GNUC_CONST;
#define TEXTURE_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_TEXTURE_MANAGER, TextureManagerPrivate))
enum  {
	TEXTURE_MANAGER_DUMMY_PROPERTY
};
TextureManager* texture_manager_new (void);
TextureManager* texture_manager_construct (GType object_type);
Texture* texture_manager_load (TextureManager* self, const gchar* identifier, const gchar* filename, SDL_Renderer* renderer);
gboolean texture_manager_texture_loaded (TextureManager* self, const gchar* identifier);
void texture_manager_draw (TextureManager* self, const gchar* identifier, SDL_Rect* dst, SDL_Renderer* renderer);
void texture_manager_draw_frame (TextureManager* self, const gchar* identifier, SDL_Rect* dst, gint row, gint column, SDL_RendererFlip flip, SDL_Renderer* renderer);
static void texture_manager_finalize (GObject* obj);


Texture* texture_construct (GType object_type, SDL_Texture** texture) {
	Texture * self = NULL;
	SDL_Texture* _tmp0_ = NULL;
	g_return_val_if_fail (*texture != NULL, NULL);
	self = (Texture*) g_object_new (object_type, NULL);
	_tmp0_ = *texture;
	*texture = NULL;
	_SDL_DestroyTexture0 (self->priv->texture);
	self->priv->texture = _tmp0_;
	return self;
}


Texture* texture_new (SDL_Texture** texture) {
	return texture_construct (TYPE_TEXTURE, texture);
}


SDL_Texture* texture_get_texture (Texture* self) {
	SDL_Texture* result = NULL;
	SDL_Texture* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->texture;
	result = _tmp0_;
	return result;
}


static void texture_class_init (TextureClass * klass) {
	texture_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TexturePrivate));
	G_OBJECT_CLASS (klass)->finalize = texture_finalize;
}


static void texture_instance_init (Texture * self) {
	self->priv = TEXTURE_GET_PRIVATE (self);
}


static void texture_finalize (GObject* obj) {
	Texture * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_TEXTURE, Texture);
	_SDL_DestroyTexture0 (self->priv->texture);
	G_OBJECT_CLASS (texture_parent_class)->finalize (obj);
}


GType texture_get_type (void) {
	static volatile gsize texture_type_id__volatile = 0;
	if (g_once_init_enter (&texture_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TextureClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) texture_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Texture), 0, (GInstanceInitFunc) texture_instance_init, NULL };
		GType texture_type_id;
		texture_type_id = g_type_register_static (G_TYPE_OBJECT, "Texture", &g_define_type_info, 0);
		g_once_init_leave (&texture_type_id__volatile, texture_type_id);
	}
	return texture_type_id__volatile;
}


TextureManager* texture_manager_construct (GType object_type) {
	TextureManager * self = NULL;
	GeeHashMap* _tmp0_ = NULL;
	self = (TextureManager*) g_object_new (object_type, NULL);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, TYPE_TEXTURE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->map);
	self->priv->map = (GeeMap*) _tmp0_;
	return self;
}


TextureManager* texture_manager_new (void) {
	return texture_manager_construct (TYPE_TEXTURE_MANAGER);
}


Texture* texture_manager_load (TextureManager* self, const gchar* identifier, const gchar* filename, SDL_Renderer* renderer) {
	Texture* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	SDL_Texture* texture = NULL;
	SDL_Renderer* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	SDL_Texture* _tmp4_ = NULL;
	Texture* t = NULL;
	Texture* _tmp5_ = NULL;
	GeeMap* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (identifier != NULL, NULL);
	g_return_val_if_fail (filename != NULL, NULL);
	g_return_val_if_fail (renderer != NULL, NULL);
	_tmp0_ = filename;
	_tmp1_ = identifier;
	g_debug ("texturemanager.vala:23: LOAD TEXTURE: %s WITH IDENTIFIER: %s", _tmp0_, _tmp1_);
	_tmp2_ = renderer;
	_tmp3_ = filename;
	_tmp4_ = IMG_LoadTexture (_tmp2_, _tmp3_);
	texture = _tmp4_;
	_tmp5_ = texture_new (&texture);
	t = _tmp5_;
	_tmp6_ = self->priv->map;
	_tmp7_ = identifier;
	gee_map_set (_tmp6_, _tmp7_, t);
	result = t;
	_SDL_DestroyTexture0 (texture);
	return result;
}


gboolean texture_manager_texture_loaded (TextureManager* self, const gchar* identifier) {
	gboolean result = FALSE;
	GeeMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (identifier != NULL, FALSE);
	_tmp0_ = self->priv->map;
	_tmp1_ = identifier;
	_tmp2_ = gee_map_has_key (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


void texture_manager_draw (TextureManager* self, const gchar* identifier, SDL_Rect* dst, SDL_Renderer* renderer) {
	SDL_Rect src = {0};
	SDL_Rect _tmp0_ = {0};
	guint _tmp1_ = 0U;
	SDL_Rect _tmp2_ = {0};
	guint _tmp3_ = 0U;
	SDL_Rect _tmp4_ = {0};
	SDL_Renderer* _tmp5_ = NULL;
	GeeMap* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gpointer _tmp8_ = NULL;
	Texture* _tmp9_ = NULL;
	SDL_Texture* _tmp10_ = NULL;
	SDL_Rect _tmp11_ = {0};
	SDL_Rect _tmp12_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (identifier != NULL);
	g_return_if_fail (dst != NULL);
	g_return_if_fail (renderer != NULL);
	_tmp0_ = *dst;
	_tmp1_ = _tmp0_.w;
	_tmp2_ = *dst;
	_tmp3_ = _tmp2_.h;
	memset (&_tmp4_, 0, sizeof (SDL_Rect));
	_tmp4_.x = 0;
	_tmp4_.y = 0;
	_tmp4_.w = _tmp1_;
	_tmp4_.h = _tmp3_;
	src = _tmp4_;
	_tmp5_ = renderer;
	_tmp6_ = self->priv->map;
	_tmp7_ = identifier;
	_tmp8_ = gee_map_get (_tmp6_, _tmp7_);
	_tmp9_ = (Texture*) _tmp8_;
	_tmp10_ = texture_get_texture (_tmp9_);
	_tmp11_ = src;
	_tmp12_ = *dst;
	SDL_RenderCopy (_tmp5_, _tmp10_, &_tmp11_, &_tmp12_);
	_g_object_unref0 (_tmp9_);
}


void texture_manager_draw_frame (TextureManager* self, const gchar* identifier, SDL_Rect* dst, gint row, gint column, SDL_RendererFlip flip, SDL_Renderer* renderer) {
	SDL_Rect src = {0};
	SDL_Rect _tmp0_ = {0};
	guint _tmp1_ = 0U;
	gint _tmp2_ = 0;
	SDL_Rect _tmp3_ = {0};
	guint _tmp4_ = 0U;
	gint _tmp5_ = 0;
	SDL_Rect _tmp6_ = {0};
	guint _tmp7_ = 0U;
	SDL_Rect _tmp8_ = {0};
	guint _tmp9_ = 0U;
	SDL_Rect _tmp10_ = {0};
	gint _tmp11_ = 0;
	gint _tmp12_ = 0;
	guint _tmp13_ = 0U;
	guint _tmp14_ = 0U;
	SDL_Renderer* _tmp15_ = NULL;
	GeeMap* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	gpointer _tmp18_ = NULL;
	Texture* _tmp19_ = NULL;
	SDL_Texture* _tmp20_ = NULL;
	SDL_Rect _tmp21_ = {0};
	SDL_Rect _tmp22_ = {0};
	SDL_RendererFlip _tmp23_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (identifier != NULL);
	g_return_if_fail (dst != NULL);
	g_return_if_fail (renderer != NULL);
	_tmp0_ = *dst;
	_tmp1_ = _tmp0_.w;
	_tmp2_ = column;
	_tmp3_ = *dst;
	_tmp4_ = _tmp3_.h;
	_tmp5_ = row;
	_tmp6_ = *dst;
	_tmp7_ = _tmp6_.w;
	_tmp8_ = *dst;
	_tmp9_ = _tmp8_.h;
	memset (&_tmp10_, 0, sizeof (SDL_Rect));
	_tmp10_.x = ((gint) _tmp1_) * _tmp2_;
	_tmp10_.y = ((gint) _tmp4_) * _tmp5_;
	_tmp10_.w = _tmp7_;
	_tmp10_.h = _tmp9_;
	src = _tmp10_;
	_tmp11_ = (*dst).x;
	(*dst).x = _tmp11_ * 4;
	_tmp12_ = (*dst).y;
	(*dst).y = _tmp12_ * 4;
	_tmp13_ = (*dst).w;
	(*dst).w = _tmp13_ * 4;
	_tmp14_ = (*dst).h;
	(*dst).h = _tmp14_ * 4;
	_tmp15_ = renderer;
	_tmp16_ = self->priv->map;
	_tmp17_ = identifier;
	_tmp18_ = gee_map_get (_tmp16_, _tmp17_);
	_tmp19_ = (Texture*) _tmp18_;
	_tmp20_ = texture_get_texture (_tmp19_);
	_tmp21_ = src;
	_tmp22_ = *dst;
	_tmp23_ = flip;
	SDL_RenderCopyEx (_tmp15_, _tmp20_, &_tmp21_, &_tmp22_, (gdouble) 0, NULL, _tmp23_);
	_g_object_unref0 (_tmp19_);
}


static void texture_manager_class_init (TextureManagerClass * klass) {
	texture_manager_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TextureManagerPrivate));
	G_OBJECT_CLASS (klass)->finalize = texture_manager_finalize;
}


static void texture_manager_instance_init (TextureManager * self) {
	self->priv = TEXTURE_MANAGER_GET_PRIVATE (self);
}


static void texture_manager_finalize (GObject* obj) {
	TextureManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_TEXTURE_MANAGER, TextureManager);
	_g_object_unref0 (self->priv->map);
	G_OBJECT_CLASS (texture_manager_parent_class)->finalize (obj);
}


GType texture_manager_get_type (void) {
	static volatile gsize texture_manager_type_id__volatile = 0;
	if (g_once_init_enter (&texture_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TextureManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) texture_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TextureManager), 0, (GInstanceInitFunc) texture_manager_instance_init, NULL };
		GType texture_manager_type_id;
		texture_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "TextureManager", &g_define_type_info, 0);
		g_once_init_leave (&texture_manager_type_id__volatile, texture_manager_type_id);
	}
	return texture_manager_type_id__volatile;
}



