/* fontmanager.c generated by valac 0.32.0, the Vala compiler
 * generated from fontmanager.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL_ttf.h>
#include <SDL2/SDL.h>


#define TYPE_FONT_MANAGER (font_manager_get_type ())
#define FONT_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FONT_MANAGER, FontManager))
#define FONT_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FONT_MANAGER, FontManagerClass))
#define IS_FONT_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FONT_MANAGER))
#define IS_FONT_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FONT_MANAGER))
#define FONT_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FONT_MANAGER, FontManagerClass))

typedef struct _FontManager FontManager;
typedef struct _FontManagerClass FontManagerClass;
typedef struct _FontManagerPrivate FontManagerPrivate;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _TTF_CloseFont0(var) ((var == NULL) ? NULL : (var = (TTF_CloseFont (var), NULL)))

struct _FontManager {
	GObject parent_instance;
	FontManagerPrivate * priv;
	GHashTable* map;
};

struct _FontManagerClass {
	GObjectClass parent_class;
};


static gpointer font_manager_parent_class = NULL;

GType font_manager_get_type (void) G_GNUC_CONST;
enum  {
	FONT_MANAGER_DUMMY_PROPERTY
};
FontManager* font_manager_new (void);
FontManager* font_manager_construct (GType object_type);
static void _g_free0_ (gpointer var);
static void _TTF_CloseFont0_ (gpointer var);
void font_manager_load (FontManager* self, const gchar* identifier, const gchar* filename, gint ptsize);
TTF_Font* font_manager_getFont (FontManager* self, const gchar* identifier);
gboolean font_manager_loaded (FontManager* self, const gchar* identifier);
static void font_manager_finalize (GObject* obj);


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _TTF_CloseFont0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (TTF_CloseFont (var), NULL));
}


FontManager* font_manager_construct (GType object_type) {
	FontManager * self = NULL;
	GHashFunc _tmp0_ = NULL;
	GEqualFunc _tmp1_ = NULL;
	GHashTable* _tmp2_ = NULL;
	self = (FontManager*) g_object_new (object_type, NULL);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _TTF_CloseFont0_);
	_g_hash_table_unref0 (self->map);
	self->map = _tmp2_;
	return self;
}


FontManager* font_manager_new (void) {
	return font_manager_construct (TYPE_FONT_MANAGER);
}


void font_manager_load (FontManager* self, const gchar* identifier, const gchar* filename, gint ptsize) {
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	TTF_Font* f = NULL;
	const gchar* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	TTF_Font* _tmp5_ = NULL;
	TTF_Font* _tmp6_ = NULL;
	GHashTable* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	TTF_Font* _tmp11_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (identifier != NULL);
	g_return_if_fail (filename != NULL);
	_tmp0_ = filename;
	_tmp1_ = identifier;
	_tmp2_ = ptsize;
	g_debug ("fontmanager.vala:9: LOAD FONT: %s WITH IDENTIFIER %s AND PTSIZE %d", _tmp0_, _tmp1_, _tmp2_);
	_tmp3_ = filename;
	_tmp4_ = ptsize;
	_tmp5_ = TTF_OpenFont (_tmp3_, _tmp4_);
	f = _tmp5_;
	_tmp6_ = f;
	if (_tmp6_ == NULL) {
		const gchar* _tmp7_ = NULL;
		_tmp7_ = SDL_GetError ();
		g_error ("fontmanager.vala:13: %s", _tmp7_);
	}
	_tmp8_ = self->map;
	_tmp9_ = identifier;
	_tmp10_ = g_strdup (_tmp9_);
	_tmp11_ = f;
	f = NULL;
	g_hash_table_insert (_tmp8_, _tmp10_, _tmp11_);
	_TTF_CloseFont0 (f);
}


TTF_Font* font_manager_getFont (FontManager* self, const gchar* identifier) {
	TTF_Font* result = NULL;
	GHashTable* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (identifier != NULL, NULL);
	_tmp0_ = self->map;
	_tmp1_ = identifier;
	_tmp2_ = g_hash_table_lookup (_tmp0_, _tmp1_);
	result = (TTF_Font*) _tmp2_;
	return result;
}


gboolean font_manager_loaded (FontManager* self, const gchar* identifier) {
	gboolean result = FALSE;
	GHashTable* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (identifier != NULL, FALSE);
	_tmp0_ = self->map;
	_tmp1_ = identifier;
	_tmp2_ = g_hash_table_contains (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void font_manager_class_init (FontManagerClass * klass) {
	font_manager_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = font_manager_finalize;
}


static void font_manager_instance_init (FontManager * self) {
}


static void font_manager_finalize (GObject* obj) {
	FontManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FONT_MANAGER, FontManager);
	_g_hash_table_unref0 (self->map);
	G_OBJECT_CLASS (font_manager_parent_class)->finalize (obj);
}


GType font_manager_get_type (void) {
	static volatile gsize font_manager_type_id__volatile = 0;
	if (g_once_init_enter (&font_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FontManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) font_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FontManager), 0, (GInstanceInitFunc) font_manager_instance_init, NULL };
		GType font_manager_type_id;
		font_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "FontManager", &g_define_type_info, 0);
		g_once_init_leave (&font_manager_type_id__volatile, font_manager_type_id);
	}
	return font_manager_type_id__volatile;
}



